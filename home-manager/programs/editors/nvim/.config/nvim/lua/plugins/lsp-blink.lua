-- local utils = require("config.utils")
--
-- local non_nixos_lspconfig_deps = {
-- 	{ "williamboman/mason.nvim", config = true },
-- 	"williamboman/mason-lspconfig.nvim",
-- 	"WhoIsSethDaniel/mason-tool-installer.nvim",
-- }
--
-- local get_lspconfig_deps = function()
-- 	local hostname = utils.get_hostname()
-- 	local deps = {
-- 		"saghen/blink.cmp",
-- 	}
-- 	if hostname == "hp-laptop" or hostname == "dell-desktop" then
-- 		return deps
-- 	else
-- 		for _, dep in ipairs(non_nixos_lspconfig_deps) do
-- 			table.insert(deps, dep)
-- 		end
-- 		return deps
-- 	end
-- end
--
-- local setup_lsp_common = function()
-- 	vim.api.nvim_create_autocmd("LspAttach", {
-- 		group = vim.api.nvim_create_augroup("lsp-attach", { clear = true }),
-- 		callback = function(event)
-- 			local map = function(keys, func, desc, mode)
-- 				mode = mode or "n"
-- 				vim.keymap.set(mode, keys, func, { buffer = event.buf, desc = "LSP: " .. desc })
-- 			end
--
-- 			-- Jump to the definition of the word under your cursor.
-- 			--  This is where a variable was first declared, or where a function is defined, etc.
-- 			--  To jump back, press <C-t>.
-- 			map("gd", require("telescope.builtin").lsp_definitions, "[G]oto [D]efinition")
--
-- 			-- Find references for the word under your cursor.
-- 			map("gr", require("telescope.builtin").lsp_references, "[G]oto [R]eferences")
--
-- 			-- Jump to the implementation of the word under your cursor.
-- 			--  Useful when your language has ways of declaring types without an actual implementation.
-- 			map("gI", require("telescope.builtin").lsp_implementations, "[G]oto [I]mplementation")
--
-- 			-- Jump to the type of the word under your cursor.
-- 			--  Useful when you're not sure what type a variable is and you want to see
-- 			--  the definition of its *type*, not where it was *defined*.
-- 			map("<leader>D", require("telescope.builtin").lsp_type_definitions, "Type [D]efinition")
--
-- 			-- Fuzzy find all the symbols in your current document.
-- 			--  Symbols are things like variables, functions, types, etc.
-- 			map("<leader>ds", require("telescope.builtin").lsp_document_symbols, "[D]ocument [S]ymbols")
--
-- 			-- Fuzzy find all the symbols in your current workspace.
-- 			--  Similar to document symbols, except searches over your entire project.
-- 			map("<leader>ws", require("telescope.builtin").lsp_dynamic_workspace_symbols, "[W]orkspace [S]ymbols")
--
-- 			-- Rename the variable under your cursor.
-- 			--  Most Language Servers support renaming across files, etc.
-- 			map("<leader>rn", vim.lsp.buf.rename, "[R]e[n]ame")
--
-- 			-- Execute a code action, usually your cursor needs to be on top of an error
-- 			-- or a suggestion from your LSP for this to activate.
-- 			map("<leader>ca", vim.lsp.buf.code_action, "[C]ode [A]ction", { "n", "x" })
--
-- 			-- WARN: This is not Goto Definition, this is Goto Declaration.
-- 			--  For example, in C this would take you to the header.
-- 			map("gD", vim.lsp.buf.declaration, "[G]oto [D]eclaration")
--
-- 			map("<leader>td", function()
-- 				vim.diagnostic.enable(not vim.diagnostic.is_enabled())
-- 			end, "Lsp: [T]oggle Inline Diagnostics")
--
-- 			local virtual_text_enabled = false
-- 			local ToggleVirtualText = function()
-- 				virtual_text_enabled = not virtual_text_enabled
-- 				vim.diagnostic.config({
-- 					virtual_text = virtual_text_enabled,
-- 				})
-- 			end
--
-- 			map("<leader>tv", ToggleVirtualText, "Lsp: [T]oggle [V]irtual Text")
--
-- 			vim.diagnostic.config({
-- 				virtual_text = virtual_text_enabled,
-- 				signs = {
-- 					text = {
-- 						[vim.diagnostic.severity.ERROR] = " ",
-- 						[vim.diagnostic.severity.WARN] = " ",
-- 						[vim.diagnostic.severity.HINT] = " ",
-- 						[vim.diagnostic.severity.INFO] = " ",
-- 					},
-- 				},
-- 				underline = true,
-- 				update_in_insert = false,
-- 				severity_sort = true,
-- 			})
--
-- 			-- The following two autocommands are used to highlight references of the
-- 			-- word under your cursor when your cursor rests there for a little while.
-- 			--    See `:help CursorHold` for information about when this is executed
-- 			--
-- 			-- When you move your cursor, the highlights will be cleared (the second autocommand).
-- 			local client = vim.lsp.get_client_by_id(event.data.client_id)
-- 			if client and client.supports_method(vim.lsp.protocol.Methods.textDocument_documentHighlight) then
-- 				local highlight_augroup = vim.api.nvim_create_augroup("lsp-highlight", { clear = false })
-- 				vim.api.nvim_create_autocmd({ "CursorHold", "CursorHoldI" }, {
-- 					buffer = event.buf,
-- 					group = highlight_augroup,
-- 					callback = vim.lsp.buf.document_highlight,
-- 				})
--
-- 				vim.api.nvim_create_autocmd({ "CursorMoved", "CursorMovedI" }, {
-- 					buffer = event.buf,
-- 					group = highlight_augroup,
-- 					callback = vim.lsp.buf.clear_references,
-- 				})
--
-- 				vim.api.nvim_create_autocmd("LspDetach", {
-- 					group = vim.api.nvim_create_augroup("lsp-detach", { clear = true }),
-- 					callback = function(event2)
-- 						vim.lsp.buf.clear_references()
-- 						vim.api.nvim_clear_autocmds({ group = "lsp-highlight", buffer = event2.buf })
-- 					end,
-- 				})
-- 			end
--
-- 			-- The following code creates a keymap to toggle inlay hints in your
-- 			-- code, if the language server you are using supports them
-- 			--
-- 			-- This may be unwanted, since they displace some of your code
-- 			if client and client.supports_method(vim.lsp.protocol.Methods.textDocument_inlayHint) then
-- 				map("<leader>th", function()
-- 					vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled({ bufnr = event.buf }))
-- 				end, "[T]oggle Inlay [H]ints")
-- 			end
-- 		end,
-- 	})
-- end
--
-- local setup_servers_non_nixos = function()
-- 	-- LSP servers and clients are able to communicate to each other what features they support.
-- 	--  By default, Neovim doesn't support everything that is in the LSP specification.
-- 	--  When you add nvim-cmp, luasnip, etc. Neovim now has *more* capabilities.
--
-- 	-- Enable the following language servers
-- 	--  Feel free to add/remove any LSPs that you want here. They will automatically be installed.
-- 	--
-- 	--  Add any additional override configuration in the following tables. Available keys are:
-- 	--  - cmd (table): Override the default command used to start the server
-- 	--  - filetypes (table): Override the default list of associated filetypes for the server
-- 	--  - capabilities (table): Override fields in capabilities. Can be used to disable certain LSP features.
-- 	--  - settings (table): Override the default settings passed when initializing the server.
-- 	--        For example, to see the options for `lua_ls`, you could go to: https://luals.github.io/wiki/settings/
-- 	local servers = {
-- 		pyright = {},
-- 		lua_ls = {
-- 			-- cmd = {...},
-- 			-- filetypes = { ...},
-- 			-- capabilities = {},
-- 			settings = {
-- 				Lua = {
-- 					completion = {
-- 						callSnippet = "Replace",
-- 					},
-- 					-- You can toggle below to ignore Lua_LS's noisy `missing-fields` warnings
-- 					-- diagnostics = { disable = { 'missing-fields' } },
-- 				},
-- 			},
-- 		},
-- 	}
--
-- 	-- Ensure the servers and tools above are installed
-- 	--  To check the current status of installed tools and/or manually install
-- 	--  other tools, you can run
-- 	--    :Mason
-- 	--
-- 	--  You can press `g?` for help in this menu.
-- 	require("mason").setup()
--
-- 	-- You can add other tools here that you want Mason to install
-- 	-- for you, so that they are available from within Neovim.
-- 	local ensure_installed = vim.tbl_keys(servers or {})
-- 	vim.list_extend(ensure_installed, {
-- 		"stylua", -- Used to format Lua code
-- 	})
-- 	require("mason-tool-installer").setup({ ensure_installed = ensure_installed })
--
-- 	local lspconfig = require("lspconfig")
-- 	for server, config in pairs(servers) do
-- 		-- passing config.capabilities to blink.cmp merges with the capabilities in your
-- 		-- 'server.capabilities', if you've defined it
-- 		config.capabilities = require("blink.cmp").get_lsp_capabilities(config.capabilities)
-- 		lspconfig[server].setup(config)
-- 	end
--
-- 	-- setup R language server ourselves
-- 	require("lspconfig").r_language_server.setup({})
-- end
--
-- local setup_servers_nixos = function()
-- 	local capabilities = require("blink.cmp").get_lsp_capabilities()
-- 	local lspconfig = require("lspconfig")
-- 	lspconfig.bashls.setup({ capabilities = capabilities })
-- 	lspconfig.hls.setup({ capabilities = capabilities })
-- 	lspconfig.julials.setup({ capabilities = capabilities })
-- 	lspconfig.nil_ls.setup({ capabilities = capabilities })
-- 	lspconfig.pyright.setup({ capabilities = capabilities })
-- 	lspconfig.ruff.setup({ capabilities = capabilities })
-- 	lspconfig.texlab.setup({ capabilities = capabilities })
-- 	lspconfig.r_language_server.setup({ capabilities = capabilities })
-- 	lspconfig.rust_analyzer.setup({ capabilities = capabilities })
--
-- 	-- require'lspconfig'.rust_analyzer.setup{
-- 	--   settings = {
-- 	--     ['rust-analyzer'] = {
-- 	--       diagnostics = {
-- 	--         enable = false;
-- 	--       }
-- 	--     }
-- 	--   }
-- 	-- }
--
-- 	lspconfig.lua_ls.setup({
-- 		-- cmd = {...},
-- 		-- filetypes = { ...},
-- 		capabilities = capabilities,
-- 		on_init = function(client)
-- 			if client.workspace_folders then
-- 				local path = client.workspace_folders[1].name
-- 				if vim.loop.fs_stat(path .. "/.luarc.json") or vim.loop.fs_stat(path .. "/.luarc.jsonc") then
-- 					return
-- 				end
-- 			end
--
-- 			client.config.settings.Lua = vim.tbl_deep_extend("force", client.config.settings.Lua, {
-- 				runtime = {
-- 					-- Tell the language server which version of Lua you're using
-- 					-- (most likely LuaJIT in the case of Neovim)
-- 					version = "LuaJIT",
-- 				},
-- 				-- Make the server aware of Neovim runtime files
-- 				workspace = {
-- 					checkThirdParty = false,
-- 					library = {
-- 						vim.env.VIMRUNTIME,
-- 						-- Depending on the usage, you might want to add additional paths here.
-- 						-- "${3rd}/luv/library"
-- 						-- "${3rd}/busted/library",
-- 					},
-- 					-- or pull in all of 'runtimepath'. NOTE: this is a lot slower and will cause issues when working on your own configuration (see https://github.com/neovim/nvim-lspconfig/issues/3189)
-- 					-- library = vim.api.nvim_get_runtime_file("", true)
-- 				},
-- 			})
-- 		end,
-- 		settings = {
-- 			Lua = {
-- 				completion = {
-- 					callSnippet = "Replace",
-- 				},
-- 				-- You can toggle below to ignore Lua_LS's noisy `missing-fields` warnings
-- 				-- diagnostics = { disable = { 'missing-fields' } },
-- 			},
-- 		},
-- 	})
-- end
--
-- local setup_lspconfig = function()
-- 	setup_lsp_common()
-- 	local hostname = utils.get_hostname()
-- 	if hostname == "hp-laptop" or hostname == "dell-desktop" then
-- 		setup_servers_nixos()
-- 	else
-- 		setup_servers_non_nixos()
-- 	end
-- end
--
-- return {
-- 	-- LSP plugins
-- 	{
-- 		-- `lazydev` configures Lua LSP for your Neovim config, runtime and plugins
-- 		-- used for completion, annotations and signatures of Neovim apis
-- 		"folke/lazydev.nvim",
-- 		ft = "lua",
-- 		opts = {
-- 			library = {
-- 				-- Load luvit types when the `vim.uv` word is found
-- 				{ path = "luvit-meta/library", words = { "vim%.uv" } },
-- 			},
-- 		},
-- 	},
-- 	{ "Bilal2453/luvit-meta", lazy = true },
-- 	{
-- 		"saghen/blink.cmp",
-- 		lazy = false, -- lazy loading handled internally
-- 		-- optional: provides snippets for the snippet source
-- 		dependencies = {
-- 			"rafamadriz/friendly-snippets",
-- 			"giuxtaposition/blink-cmp-copilot",
-- 		},
--
-- 		-- use a release tag to download pre-built binaries
-- 		version = "v0.*",
-- 		-- OR build from source, requires nightly: https://rust-lang.github.io/rustup/concepts/channels.html#working-with-nightly-rust
-- 		-- build = 'cargo build --release',
-- 		-- If you use nix, you can build from source using latest nightly rust with:
-- 		-- build = 'nix run .#build-plugin',
--
-- 		---@module 'blink.cmp'
-- 		---@type blink.cmp.Config
-- 		opts = {
-- 			-- 'default' for mappings similar to built-in completion
-- 			-- 'super-tab' for mappings similar to vscode (tab to accept, arrow keys to navigate)
-- 			-- 'enter' for mappings similar to 'super-tab' but with 'enter' to accept
-- 			-- see the "default configuration" section below for full documentation on how to define
-- 			-- your own keymap.
-- 			keymap = {
-- 				["<C-space>"] = { "show", "show_documentation", "hide_documentation", "fallback" },
-- 				["<C-e>"] = { "hide" },
-- 				["<Tab>"] = { "select_next", "fallback" },
-- 				["<S-Tab>"] = { "select_prev", "fallback" },
-- 				["<CR>"] = { "accept", "fallback" },
-- 				["<C-h>"] = { "snippet_forward", "fallback" },
-- 				["<C-l>"] = { "snippet_backward", "fallback" },
-- 				["<Up>"] = { "select_prev", "fallback" },
-- 				["<Down>"] = { "select_next", "fallback" },
-- 				["<C-p>"] = { "select_prev", "fallback" },
-- 				["<C-n>"] = { "select_next", "fallback" },
-- 			},
--
-- 			completion = {
-- 				menu = {
-- 					draw = {
-- 						columns = { { "label", "label_description", gap = 1 }, { "kind_icon", "kind" } },
-- 					},
-- 				},
-- 			},
--
-- 			appearance = {
-- 				-- Sets the fallback highlight groups to nvim-cmp's highlight groups
-- 				-- Useful for when your theme doesn't support blink.cmp
-- 				-- will be removed in a future release
-- 				use_nvim_cmp_as_default = true,
-- 				-- Set to 'mono' for 'Nerd Font Mono' or 'normal' for 'Nerd Font'
-- 				-- Adjusts spacing to ensure icons are aligned
-- 				nerd_font_variant = "mono",
-- 				-- Blink does not expose its default kind icons so you must copy them all (or set your custom ones) and add Copilot
-- 				kind_icons = {
-- 					Copilot = "",
-- 					Text = "󰉿",
-- 					Method = "󰊕",
-- 					Function = "󰊕",
-- 					Constructor = "󰒓",
--
-- 					Field = "󰜢",
-- 					Variable = "󰆦",
-- 					Property = "󰖷",
--
-- 					Class = "󱡠",
-- 					Interface = "󱡠",
-- 					Struct = "󱡠",
-- 					Module = "󰅩",
--
-- 					Unit = "󰪚",
-- 					Value = "󰦨",
-- 					Enum = "󰦨",
-- 					EnumMember = "󰦨",
--
-- 					Keyword = "󰻾",
-- 					Constant = "󰏿",
--
-- 					Snippet = "󱄽",
-- 					Color = "󰏘",
-- 					File = "󰈔",
-- 					Reference = "󰬲",
-- 					Folder = "󰉋",
-- 					Event = "󱐋",
-- 					Operator = "󰪚",
-- 					TypeParameter = "󰬛",
-- 				},
-- 			},
--
-- 			-- default list of enabled providers defined so that you can extend it
-- 			-- elsewhere in your config, without redefining it, via `opts_extend`
-- 			sources = {
-- 				default = { "lsp", "path", "snippets", "buffer", "lazydev", "codecompanion", "copilot" },
-- 				completion = {
-- 					enabled_providers = { "lsp", "path", "snippets", "buffer", "lazydev", "codecompanion", "copilot" },
-- 				},
-- 				providers = {
-- 					-- dont show LuaLS require statements when lazydev has items
-- 					lsp = { fallback_for = { "lazydev" } },
-- 					lazydev = { name = "LazyDev", module = "lazydev.integrations.blink" },
-- 					copilot = {
-- 						name = "copilot",
-- 						module = "blink-cmp-copilot",
-- 						score_offset = 100,
-- 						async = true,
-- 						transform_items = function(_, items)
-- 							local CompletionItemKind = require("blink.cmp.types").CompletionItemKind
-- 							local kind_idx = #CompletionItemKind + 1
-- 							CompletionItemKind[kind_idx] = "Copilot"
-- 							for _, item in ipairs(items) do
-- 								item.kind = kind_idx
-- 							end
-- 							return items
-- 						end,
-- 					},
-- 					codecompanion = {
-- 						name = "CodeCompanion",
-- 						module = "codecompanion.providers.completion.blink",
-- 						enabled = true,
-- 					},
-- 				},
-- 				-- optionally disable cmdline completions
-- 				-- cmdline = {},
-- 			},
--
-- 			-- experimental signature help support
-- 			signature = { enabled = true },
-- 		},
-- 		-- allows extending the providers array elsewhere in your config
-- 		-- without having to redefine it
-- 		opts_extend = { "sources.default" },
-- 	},
-- 	{
-- 		-- Main LSP Configuration
-- 		"neovim/nvim-lspconfig",
-- 		dependencies = get_lspconfig_deps(),
-- 		config = setup_lspconfig,
-- 	},
-- 	{
-- 		"nvimdev/lspsaga.nvim",
-- 		config = function()
-- 			require("lspsaga").setup({})
-- 			vim.keymap.set(
-- 				"n",
-- 				"<leader>cl",
-- 				"<cmd>Lspsaga show_line_diagnostics<cr>",
-- 				{ desc = "Lspsaga: show line diagnostics" }
-- 			)
-- 		end,
-- 		dependencies = {
-- 			"nvim-treesitter/nvim-treesitter", -- optional
-- 			"nvim-tree/nvim-web-devicons", -- optional
-- 		},
-- 	},
-- 	{ -- Autoformat
-- 		-- TODO: configure this
-- 		"stevearc/conform.nvim",
-- 		event = { "BufWritePre" },
-- 		cmd = { "ConformInfo" },
-- 		keys = {
-- 			{
-- 				"<leader>cf",
-- 				function()
-- 					require("conform").format({ async = true, lsp_format = "fallback" })
-- 				end,
-- 				mode = "",
-- 				desc = "[F]ormat buffer",
-- 			},
-- 		},
-- 		opts = {
-- 			notify_on_error = false,
-- 			format_on_save = function(bufnr)
-- 				-- Disable "format_on_save lsp_fallback" for languages that don't
-- 				-- have a well standardized coding style. You can add additional
-- 				-- languages here or re-enable it for the disabled ones.
-- 				local disable_filetypes = { c = true, cpp = true }
-- 				local lsp_format_opt
-- 				if disable_filetypes[vim.bo[bufnr].filetype] then
-- 					lsp_format_opt = "never"
-- 				else
-- 					lsp_format_opt = "fallback"
-- 				end
-- 				return {
-- 					timeout_ms = 500,
-- 					lsp_format = lsp_format_opt,
-- 				}
-- 			end,
-- 			formatters_by_ft = {
-- 				lua = { "stylua" },
-- 				-- Conform can also run multiple formatters sequentially
-- 				-- python = { "isort", "black" },
-- 				--
-- 				-- You can use 'stop_after_first' to run the first available formatter from the list
-- 				-- javascript = { "prettierd", "prettier", stop_after_first = true },
-- 			},
-- 		},
-- 	},
-- }
return {}
